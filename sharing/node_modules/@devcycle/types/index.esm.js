import isString from 'lodash/isString';
import { registerDecorator, ValidateBy, buildMessage, IsBoolean, IsOptional, IsString, IsNotEmpty, IsISO31661Alpha2, IsNumber, IsDate, IsIn, IsObject, ValidateNested, IsArray } from 'class-validator';
import { Transform, Type } from 'class-transformer';
import 'reflect-metadata';
import isNumber from 'lodash/isNumber';
import isBoolean from 'lodash/isBoolean';
import isPlainObject from 'lodash/isPlainObject';
import isNull from 'lodash/isNull';
import isUndefined from 'lodash/isUndefined';
import ISO6391 from 'iso-639-1';

/******************************************************************************
Copyright (c) Microsoft Corporation.

Permission to use, copy, modify, and/or distribute this software for any
purpose with or without fee is hereby granted.

THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH
REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,
INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM
LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR
OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
PERFORMANCE OF THIS SOFTWARE.
***************************************************************************** */

function __decorate(decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
}

function __metadata(metadataKey, metadataValue) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(metadataKey, metadataValue);
}

/**
 * Validates that JSON Object is a valid JSON Object with only
 * top-level string / number / boolean / null values.
 */
function IsDVCCustomDataJSONObject(validationOptions) {
    // eslint-disable-next-line @typescript-eslint/ban-types
    return function (object, propertyName) {
        registerDecorator({
            name: 'isLongerThan',
            target: object.constructor,
            propertyName: propertyName,
            options: validationOptions,
            validator: {
                validate: validate$1,
                defaultMessage() {
                    return '$property must be a JSON Object with only string / number / boolean / null types';
                },
            },
        });
    };
}
// eslint-disable-next-line @typescript-eslint/no-explicit-any
// eslint-disable-next-line @typescript-eslint/explicit-module-boundary-types
function validate$1(json) {
    if (!isPlainObject(json))
        return false;
    for (const key in json) {
        if (!isString(key))
            return false;
        const value = json[key];
        if (isUndefined(value) ||
            !(isString(value) ||
                isNumber(value) ||
                isBoolean(value) ||
                isNull(value))) {
            return false;
        }
    }
    return true;
}

/**
 * Validates that string is not filled with spaces
 */
function IsNotBlank(validationOptions) {
    // eslint-disable-next-line @typescript-eslint/ban-types
    return function (object, propertyName) {
        registerDecorator({
            name: 'isNotBlank',
            target: object.constructor,
            propertyName: propertyName,
            options: validationOptions,
            validator: {
                validate,
            },
        });
    };
}
function validate(value) {
    return typeof value === 'string' && value.trim().length > 0;
}

const IS_ISO6391 = 'isISO6391';
/**
 * Check if the string is a valid [ISO 639-1](https://en.wikipedia.org/wiki/ISO_3166-1_alpha-2)
 * officially assigned country code.
 */
function isISO6391(value) {
    return typeof value === 'string' && isISO6391Validator(value);
}
/**
 * Check if the string is a valid [ISO 3166-1](https://en.wikipedia.org/wiki/List_of_ISO_639-1_codes) official code.
 */
function IsISO6391(validationOptions) {
    return ValidateBy({
        name: IS_ISO6391,
        validator: {
            validate: (value, args) => isISO6391(value),
            defaultMessage: buildMessage((eachPrefix) => eachPrefix + '$property must be a valid ISO6391 code', validationOptions),
        },
    }, validationOptions);
}
function isISO6391Validator(value) {
    return ISO6391.validate(value.toLocaleLowerCase());
}

const SDKTypeValues = ['client', 'server', 'mobile', 'api'];
const boolTransform = ({ value }) => {
    if (value === 'true') {
        return true;
    }
    else if (value === 'false') {
        return false;
    }
    return value;
};
const dateTransform = ({ value }) => {
    if (!value)
        return undefined;
    const numberValue = Number(value);
    if (!isNaN(numberValue)) {
        // value is a time string
        return new Date(numberValue);
    }
    else {
        // value is a date-time string
        return new Date(value);
    }
};
/**
 * Base API User Schema used by the Bucketing API where the only required field is user_id.
 */
class DVCAPIUser {
    isAnonymous;
    user_id;
    /**
     * Email used for identifying a device user in the dashboard,
     * or used for audience segmentation.
     */
    email;
    /**
     * Name of the user which can be used for identifying a device user,
     * or used for audience segmentation.
     */
    name;
    /**
     * ISO 639-1 two-letter codes
     */
    language;
    /**
     * ISO 3166 alpha-2
     */
    country;
    /**
     * Application Version, can be used for audience segmentation.
     */
    appVersion;
    /**
     * Application Build, can be used for audience segmentation.
     */
    appBuild;
    /**
     * Custom JSON data used for audience segmentation, must be limited to __kb in size.
     * Values will be logged to DevCycle's servers and available in the dashboard to view.
     */
    customData;
    /**
     * Private Custom JSON data used for audience segmentation, must be limited to __kb in size.
     * Values will not be logged to DevCycle's servers and
     * will not be available in the dashboard.
     */
    privateCustomData;
    /**
     * Set by SDK automatically
     */
    createdDate;
    /**
     * Set by SDK automatically
     */
    lastSeenDate;
    /**
     * Set by SDK to 'web'
     */
    platform;
    /**
     * Set by SDK to ??
     */
    platformVersion;
    /**
     * Set by SDK to User-Agent
     */
    deviceModel;
    /**
     * SDK type
     */
    sdkType = 'api';
    /**
     * SDK Version
     */
    sdkVersion;
}
__decorate([
    IsBoolean(),
    IsOptional(),
    Transform(boolTransform),
    __metadata("design:type", Boolean)
], DVCAPIUser.prototype, "isAnonymous", void 0);
__decorate([
    IsString(),
    IsNotBlank(),
    IsNotEmpty(),
    __metadata("design:type", String)
], DVCAPIUser.prototype, "user_id", void 0);
__decorate([
    IsString(),
    IsOptional(),
    __metadata("design:type", String)
], DVCAPIUser.prototype, "email", void 0);
__decorate([
    IsString(),
    IsOptional(),
    __metadata("design:type", String)
], DVCAPIUser.prototype, "name", void 0);
__decorate([
    IsISO6391(),
    IsString(),
    IsOptional(),
    __metadata("design:type", String)
], DVCAPIUser.prototype, "language", void 0);
__decorate([
    IsISO31661Alpha2(),
    IsOptional(),
    __metadata("design:type", String)
], DVCAPIUser.prototype, "country", void 0);
__decorate([
    IsString(),
    IsOptional(),
    __metadata("design:type", String)
], DVCAPIUser.prototype, "appVersion", void 0);
__decorate([
    IsNumber(),
    IsOptional(),
    Type(() => Number),
    __metadata("design:type", Number)
], DVCAPIUser.prototype, "appBuild", void 0);
__decorate([
    IsDVCCustomDataJSONObject(),
    IsOptional(),
    Transform(({ value }) => (isString(value) ? JSON.parse(value) : value)),
    __metadata("design:type", Object)
], DVCAPIUser.prototype, "customData", void 0);
__decorate([
    IsDVCCustomDataJSONObject(),
    IsOptional(),
    Transform(({ value }) => (isString(value) ? JSON.parse(value) : value)),
    __metadata("design:type", Object)
], DVCAPIUser.prototype, "privateCustomData", void 0);
__decorate([
    IsDate(),
    IsOptional(),
    Transform(dateTransform),
    __metadata("design:type", Date
    /**
     * Set by SDK automatically
     */
    )
], DVCAPIUser.prototype, "createdDate", void 0);
__decorate([
    IsDate(),
    IsOptional(),
    Transform(dateTransform),
    __metadata("design:type", Date
    /**
     * Set by SDK to 'web'
     */
    )
], DVCAPIUser.prototype, "lastSeenDate", void 0);
__decorate([
    IsString(),
    IsOptional(),
    __metadata("design:type", String)
], DVCAPIUser.prototype, "platform", void 0);
__decorate([
    IsString(),
    IsOptional(),
    __metadata("design:type", String)
], DVCAPIUser.prototype, "platformVersion", void 0);
__decorate([
    IsString(),
    IsOptional(),
    __metadata("design:type", String)
], DVCAPIUser.prototype, "deviceModel", void 0);
__decorate([
    IsString(),
    IsOptional(),
    IsIn(['client', 'server', 'mobile', 'api']),
    Transform(({ value }) => value),
    __metadata("design:type", String)
], DVCAPIUser.prototype, "sdkType", void 0);
__decorate([
    IsString(),
    IsOptional(),
    __metadata("design:type", String)
], DVCAPIUser.prototype, "sdkVersion", void 0);
class DVCBucketingUser extends DVCAPIUser {
    /**
     * JSON data recording user opt-in features.
     */
    optIns;
}
__decorate([
    IsOptional(),
    Transform(({ value }) => (isString(value) ? JSON.parse(value) : value)),
    __metadata("design:type", Object)
], DVCBucketingUser.prototype, "optIns", void 0);
/**
 * Client API User Schema that extends the base DVCAPIUser schema to add fields
 * from the Client SDKs like: isAnonymous, isDebug.
 * Also changes certain fields to be required from the Client SDKs.
 */
class DVCClientAPIUser {
    /**
     * Users must be explicitly defined as anonymous, where the SDK will
     * generate a random `user_id` for them. If they are `isAnonymous = false`
     * a `user_id` value must be provided.
     */
    isAnonymous;
    user_id;
    /**
     * Email used for identifying a device user in the dashboard,
     * or used for audience segmentation.
     */
    email;
    /**
     * Name of the user which can be used for identifying a device user,
     * or used for audience segmentation.
     */
    name;
    /**
     * ISO 639-1 two-letter codes
     */
    language;
    /**
     * ISO 3166 alpha-2
     */
    country;
    /**
     * Application Version, can be used for audience segmentation.
     */
    appVersion;
    /**
     * Application Build, can be used for audience segmentation.
     */
    appBuild;
    /**
     * Custom JSON data used for audience segmentation, must be limited to __kb in size.
     * Values will be logged to DevCycle's servers and available in the dashboard to view.
     */
    customData;
    /**
     * Private Custom JSON data used for audience segmentation, must be limited to __kb in size.
     * Values will not be logged to DevCycle's servers and
     * will not be available in the dashboard.
     */
    privateCustomData;
    /**
     * Set by SDK automatically
     */
    createdDate;
    /**
     * Set by SDK automatically
     */
    lastSeenDate;
    /**
     * Set by SDK to 'web'
     */
    platform;
    /**
     * Set by SDK to ??
     */
    platformVersion;
    /**
     * Set by SDK to User-Agent
     */
    deviceModel;
    /**
     * SDK type
     */
    sdkType;
    /**
     * SDK Version
     */
    sdkVersion;
    isDebug;
}
__decorate([
    IsBoolean(),
    Transform(boolTransform),
    __metadata("design:type", Boolean)
], DVCClientAPIUser.prototype, "isAnonymous", void 0);
__decorate([
    IsString(),
    IsNotBlank(),
    IsNotEmpty(),
    __metadata("design:type", String)
], DVCClientAPIUser.prototype, "user_id", void 0);
__decorate([
    IsString(),
    IsOptional(),
    __metadata("design:type", String)
], DVCClientAPIUser.prototype, "email", void 0);
__decorate([
    IsString(),
    IsOptional(),
    __metadata("design:type", String)
], DVCClientAPIUser.prototype, "name", void 0);
__decorate([
    IsISO6391(),
    IsString(),
    IsOptional(),
    __metadata("design:type", String)
], DVCClientAPIUser.prototype, "language", void 0);
__decorate([
    IsISO31661Alpha2(),
    IsOptional(),
    __metadata("design:type", String)
], DVCClientAPIUser.prototype, "country", void 0);
__decorate([
    IsString(),
    IsOptional(),
    __metadata("design:type", String)
], DVCClientAPIUser.prototype, "appVersion", void 0);
__decorate([
    IsNumber(),
    IsOptional(),
    Type(() => Number),
    __metadata("design:type", Number)
], DVCClientAPIUser.prototype, "appBuild", void 0);
__decorate([
    IsDVCCustomDataJSONObject(),
    IsOptional(),
    Transform(({ value }) => (isString(value) ? JSON.parse(value) : value)),
    __metadata("design:type", Object)
], DVCClientAPIUser.prototype, "customData", void 0);
__decorate([
    IsDVCCustomDataJSONObject(),
    IsOptional(),
    Transform(({ value }) => (isString(value) ? JSON.parse(value) : value)),
    __metadata("design:type", Object)
], DVCClientAPIUser.prototype, "privateCustomData", void 0);
__decorate([
    IsDate(),
    Transform(dateTransform),
    __metadata("design:type", Date
    /**
     * Set by SDK automatically
     */
    )
], DVCClientAPIUser.prototype, "createdDate", void 0);
__decorate([
    IsDate(),
    Transform(dateTransform),
    __metadata("design:type", Date
    /**
     * Set by SDK to 'web'
     */
    )
], DVCClientAPIUser.prototype, "lastSeenDate", void 0);
__decorate([
    IsString(),
    IsNotEmpty(),
    __metadata("design:type", String)
], DVCClientAPIUser.prototype, "platform", void 0);
__decorate([
    IsString(),
    IsNotEmpty(),
    __metadata("design:type", String)
], DVCClientAPIUser.prototype, "platformVersion", void 0);
__decorate([
    IsString(),
    IsNotEmpty(),
    __metadata("design:type", String)
], DVCClientAPIUser.prototype, "deviceModel", void 0);
__decorate([
    IsString(),
    IsIn(['client', 'mobile']),
    __metadata("design:type", String)
], DVCClientAPIUser.prototype, "sdkType", void 0);
__decorate([
    IsString(),
    IsNotEmpty(),
    __metadata("design:type", String)
], DVCClientAPIUser.prototype, "sdkVersion", void 0);
__decorate([
    IsBoolean(),
    IsOptional(),
    Transform(({ value }) => (isString(value) ? value === 'true' : value)),
    __metadata("design:type", Boolean)
], DVCClientAPIUser.prototype, "isDebug", void 0);
class DVCOptInUser {
    user_id;
}
__decorate([
    IsString(),
    IsNotBlank(),
    IsNotEmpty(),
    __metadata("design:type", String)
], DVCOptInUser.prototype, "user_id", void 0);

/**
 * Public API Event type used in CF Workers / SDKs to define the public interface to an event.
 * All DVCEvents will be be saved as type = 'customEvent' events, where customType = DVCEvent.type,
 * and clientDate = DVCEvent.date.
 */
class DVCEvent {
    /**
     * type of the event
     */
    type;
    /**
     * target / subject of event. Contextual to event type
     */
    target;
    /**
     * date the event occurred according to client
     */
    date;
    /**
     * value for numerical events. Contextual to event type
     */
    value;
    /**
     * extra metadata for event. Contextual to event type
     */
    metaData;
}
__decorate([
    IsNotEmpty(),
    IsString(),
    __metadata("design:type", String)
], DVCEvent.prototype, "type", void 0);
__decorate([
    IsOptional(),
    IsString(),
    __metadata("design:type", String)
], DVCEvent.prototype, "target", void 0);
__decorate([
    IsOptional(),
    IsNumber(),
    __metadata("design:type", Number)
], DVCEvent.prototype, "date", void 0);
__decorate([
    IsOptional(),
    IsNumber(),
    __metadata("design:type", Number)
], DVCEvent.prototype, "value", void 0);
__decorate([
    IsOptional(),
    IsObject(),
    __metadata("design:type", Object)
], DVCEvent.prototype, "metaData", void 0);
class SDKEventRequestBody {
    user;
    events;
}
__decorate([
    IsNotEmpty(),
    ValidateNested(),
    Type(() => DVCAPIUser),
    __metadata("design:type", DVCAPIUser)
], SDKEventRequestBody.prototype, "user", void 0);
__decorate([
    IsNotEmpty(),
    IsArray(),
    ValidateNested({ each: true }),
    Type(() => DVCEvent),
    __metadata("design:type", Array)
], SDKEventRequestBody.prototype, "events", void 0);

/**
 * Supported filter comparators
 */
var FilterComparator;
(function (FilterComparator) {
    FilterComparator["="] = "=";
    FilterComparator["!="] = "!=";
    FilterComparator[">"] = ">";
    FilterComparator[">="] = ">=";
    FilterComparator["<"] = "<";
    FilterComparator["<="] = "<=";
    FilterComparator["exist"] = "exist";
    FilterComparator["!exist"] = "!exist";
    FilterComparator["contain"] = "contain";
    FilterComparator["!contain"] = "!contain";
    FilterComparator["startWith"] = "startWith";
    FilterComparator["!startWith"] = "!startWith";
    FilterComparator["endWith"] = "endWith";
    FilterComparator["!endWith"] = "!endWith";
})(FilterComparator || (FilterComparator = {}));
var BooleanFilterComparator;
(function (BooleanFilterComparator) {
    BooleanFilterComparator["="] = "=";
    BooleanFilterComparator["exist"] = "exist";
    BooleanFilterComparator["!exist"] = "!exist";
})(BooleanFilterComparator || (BooleanFilterComparator = {}));
var StringFilterComparator;
(function (StringFilterComparator) {
    StringFilterComparator["="] = "=";
    StringFilterComparator["!="] = "!=";
    StringFilterComparator["exist"] = "exist";
    StringFilterComparator["!exist"] = "!exist";
    StringFilterComparator["contain"] = "contain";
    StringFilterComparator["!contain"] = "!contain";
    StringFilterComparator["startWith"] = "startWith";
    StringFilterComparator["!startWith"] = "!startWith";
    StringFilterComparator["endWith"] = "endWith";
    StringFilterComparator["!endWith"] = "!endWith";
})(StringFilterComparator || (StringFilterComparator = {}));
var NumberFilterComparator;
(function (NumberFilterComparator) {
    NumberFilterComparator["="] = "=";
    NumberFilterComparator["!="] = "!=";
    NumberFilterComparator[">"] = ">";
    NumberFilterComparator[">="] = ">=";
    NumberFilterComparator["<"] = "<";
    NumberFilterComparator["<="] = "<=";
    NumberFilterComparator["exist"] = "exist";
    NumberFilterComparator["!exist"] = "!exist";
})(NumberFilterComparator || (NumberFilterComparator = {}));
var SemverFilterComparator;
(function (SemverFilterComparator) {
    SemverFilterComparator["="] = "=";
    SemverFilterComparator["!="] = "!=";
    SemverFilterComparator[">"] = ">";
    SemverFilterComparator[">="] = ">=";
    SemverFilterComparator["<"] = "<";
    SemverFilterComparator["<="] = "<=";
    SemverFilterComparator["exist"] = "exist";
    SemverFilterComparator["!exist"] = "!exist";
})(SemverFilterComparator || (SemverFilterComparator = {}));
/**
 * Supported filter types, defines high-level audience type.
 */
var FilterType;
(function (FilterType) {
    FilterType["all"] = "all";
    FilterType["user"] = "user";
    FilterType["optIn"] = "optIn";
    FilterType["audienceMatch"] = "audienceMatch";
    // TODO: Implement later
    // listAudience = 'listAudience'
})(FilterType || (FilterType = {}));
/**
 * Supported `subType` values for `type = 'user'` filters
 */
var UserSubType;
(function (UserSubType) {
    UserSubType["user_id"] = "user_id";
    UserSubType["email"] = "email";
    UserSubType["ip"] = "ip";
    UserSubType["country"] = "country";
    UserSubType["platform"] = "platform";
    UserSubType["platformVersion"] = "platformVersion";
    UserSubType["appVersion"] = "appVersion";
    UserSubType["deviceModel"] = "deviceModel";
    UserSubType["customData"] = "customData";
})(UserSubType || (UserSubType = {}));
/**
 * ** TODO: Implement later **
 * Supported `subType` values for `type = 'listAudience'` filters.
 */
var ListAudienceSubType;
(function (ListAudienceSubType) {
    ListAudienceSubType["mixpanel"] = "mixpanel";
    ListAudienceSubType["csv"] = "csv";
})(ListAudienceSubType || (ListAudienceSubType = {}));
/**
 * Supported data key types
 */
var DataKeyType;
(function (DataKeyType) {
    DataKeyType["string"] = "String";
    DataKeyType["boolean"] = "Boolean";
    DataKeyType["number"] = "Number";
    DataKeyType["semver"] = "Semver";
})(DataKeyType || (DataKeyType = {}));
var AudienceOperator;
(function (AudienceOperator) {
    AudienceOperator["and"] = "and";
    AudienceOperator["or"] = "or";
})(AudienceOperator || (AudienceOperator = {}));
class AudienceFilter {
    /**
     * Filter type of this audience filter (user, audienceTemplate etc.)
     */
    type;
    /**
     * Sub type of this filter (appVersion, mixpanel etc.)
     */
    subType;
    /**
     * Comparator to use if this is a filter
     */
    comparator;
    /**
     * Data Key used for custom data and other filter sub-type that require a key-value mapping.
     */
    dataKey;
    /**
     * Data Key used for custom data and other filter sub-type that require a key-value mapping.
     */
    dataKeyType;
    /**
     * Filter values to segment against, must be set for all filter types other than 'all'
     */
    values;
    /**
     * Array of audience id's for filters of type audienceMatch
     */
    _audiences;
}
/**
 * Audience filter used to describe a segmentation for a user audience.
 */
class AudienceFilterOrOperator {
    /**
     * Filter type of this audience filter (user, audienceTemplate etc.)
     */
    type;
    /**
     * Sub type of this filter (appVersion, mixpanel etc.)
     */
    subType;
    /**
     * Comparator to use if this is a filter
     */
    comparator;
    /**
     * Data Key used for custom data and other filter sub-type that require a key-value mapping.
     */
    dataKey;
    /**
     * Data Key used for custom data and other filter sub-type that require a key-value mapping.
     */
    dataKeyType;
    /**
     * Filter values to segment against, must be set for all filter types other than 'all'
     */
    values;
    /**
     * Operator type if this object represents an operator, and not a filter
     */
    operator;
    /**
     * Array of audience id's for filters of type audienceMatch
     */
    _audiences;
    /**
     * Filters to apply using the "operator" operation if this is an operator object
     */
    filters;
}
/**
 * ** Initially only `and` operator will be supported **
 * Special filter used to establish a boolean operator. Can be used for top-level OR, etc.
 */
class TopLevelOperator {
    filters;
    operator;
}
/**
 * Audience model used for describing a user segmenting audience
 */
class Audience {
    /**
     * Mongo primary _id.
     */
    _id;
    /**
     * Audience filters, describing logic for segmenting users
     */
    filters;
}

class Environment {
    /**
     * Mongo primary _id.
     */
    _id;
    /**
     * Unique key by Project, can be used in the SDK / API to reference by 'key' rather then _id.
     * Must only contain lower-case characters and `_` or `-`.
     */
    key;
}

var TargetingRuleTypes;
(function (TargetingRuleTypes) {
    TargetingRuleTypes["override"] = "override";
})(TargetingRuleTypes || (TargetingRuleTypes = {}));
class RolloutStage {
    /**
     * Defines the transition into this percentage level.
     */
    type;
    /**
     * Date the target percentage below should be fully applied.
     */
    date;
    /**
     * Target percentage this step should reach by the above date.
     */
    percentage;
}
__decorate([
    Type(() => Date),
    __metadata("design:type", Date
    /**
     * Target percentage this step should reach by the above date.
     */
    )
], RolloutStage.prototype, "date", void 0);
/**
 * Defines rollout configuration for a Target.
 */
class Rollout {
    /**
     * Type of rollout
     */
    type;
    /**
     * Rollout start percentage
     */
    startPercentage;
    /**
     * Date to start rollout
     */
    startDate;
    /**
     * Stages of rollout
     */
    stages;
}
__decorate([
    Type(() => Date),
    __metadata("design:type", Date
    /**
     * Stages of rollout
     */
    )
], Rollout.prototype, "startDate", void 0);
__decorate([
    Type(() => RolloutStage),
    __metadata("design:type", Array)
], Rollout.prototype, "stages", void 0);
class TargetDistribution {
    /**
     * Variation _id from `feature.variations`
     */
    _variation;
    /**
     * Distribution percentage for the variation
     */
    percentage;
}
class TargetAudience {
    // this is leftover from legacy config format and is unused, but leads to parsing errors if removed
    // we are going to write dummy strings here going forward
    _id;
    filters;
}
/**
 * Defines an Audience Target including the Audience model, rollout, and variation distribution
 * _id needed as it will be used as the seed in the hashing function to determine a given users position
 * in the bucketing and rollout
 */
class Target {
    _id;
    /**
     * Audience model describing target segmentation.
     */
    _audience;
    /**
     * Rollout sub-document describing how a Target's audience is rolled out
     */
    rollout;
    /**
     * Specifies variation distribution percentages for features
     */
    distribution;
    /**
     * Field indicating a special kind of targeting rule. Normally blank.
     * Currently indicates virtual targeting rules generated due to overrides.
     */
    type;
    /**
     * Bucketing key to use for this target. If not provided, user_id will be used.
     */
    bucketingKey;
}
__decorate([
    Type(() => Rollout),
    __metadata("design:type", Rollout
    /**
     * Specifies variation distribution percentages for features
     */
    )
], Target.prototype, "rollout", void 0);
class FeaturePrerequisites {
    _feature;
    comparator;
}
class FeatureWinningVariation {
    _variation;
    updatedAt;
}
/**
 * Feature Configuration Model. Defines the Environment-level model for a given feature.
 */
class FeatureConfiguration {
    /**
     * Mongo primary _id.
     */
    _id;
    /**
     * **Implement Later**
     *
     * Defines pre-requisite features that can describe that a user must or must not
     * be bucketed into another feature to be allowed to be bucketed into this feature.
     *
     * Pre-requisites are evaluated before `_winningVariation`,  `forcedUsers`, and `targets`.
     */
    prerequisites;
    /**
     * **Implement Later**
     *
     * Defines the winning variation delivered to all users.
     * Evaluated before `forcedUsers` and `targets`.
     */
    winningVariation;
    /**
     * **Implement Later**
     * Map of `user_id` to `_variation`
     * Defines the list of `user_ids` for which users should be forced into specific variations.
     * `forcedUsers` will be evaluated before `targets`
     */
    forcedUsers;
    /**
     * Defines the targets to evaluate what variation a user should be delivered.
     */
    targets;
}
__decorate([
    Type(() => Target),
    __metadata("design:type", Array)
], FeatureConfiguration.prototype, "targets", void 0);

var FeatureSource;
(function (FeatureSource) {
    FeatureSource["api"] = "api";
    FeatureSource["dashboard"] = "dashboard";
})(FeatureSource || (FeatureSource = {}));
class Variation {
    /**
     * Mongo primary _id.
     */
    _id;
    name;
    key;
    /**
     * Defining variable values.
     */
    variables;
}
var FeatureType;
(function (FeatureType) {
    FeatureType["release"] = "release";
    FeatureType["experiment"] = "experiment";
    FeatureType["permission"] = "permission";
    FeatureType["ops"] = "ops";
})(FeatureType || (FeatureType = {}));
/**
 * Feature Model. Defines the project-level "container" for a given feature
 */
class Feature {
    /**
     * Mongo primary _id.
     */
    _id;
    /**
     * Define the feature type.
     */
    type;
    /**
     * Unique key by Project, can be used in the SDK / API to reference by 'key' rather than _id.
     * Must only contain lower-case characters and `_` or `-`.
     */
    key;
    /**
     * Variation configurations to be used by feature configurations.
     */
    variations;
    configuration;
    /**
     * Defines feature-level settings
     */
    settings;
    /**
     * List of tags for feature
     */
    tags;
}
__decorate([
    Type(() => FeatureConfiguration),
    __metadata("design:type", FeatureConfiguration)
], Feature.prototype, "configuration", void 0);

class Project {
    _id;
    /**
     * Unique key by Organization, can be used in the SDK / API to reference by 'key' rather then _id
     * Must only contain lower-case characters and `_` or `-`
     */
    key;
    a0_organization;
    settings;
}

var VariableSource;
(function (VariableSource) {
    VariableSource["api"] = "api";
    VariableSource["dashboard"] = "dashboard";
    VariableSource["clientSDK"] = "clientSDK";
    VariableSource["serverSDK"] = "serverSDK";
})(VariableSource || (VariableSource = {}));
/**
 * Variable model, defines the project-level variables used in SDKs to change functionality.
 */
class Variable {
    /**
     * Mongo primary _id.
     */
    _id;
    /**
     * Variable schema type
     */
    type;
    /**
     * Unique key by Project. Used in the SDKs as the main reference for variables.
     * Must only contain lower-case characters and `_` or `-`.
     */
    key;
}
/**
 * Supported variable types
 */
var VariableType;
(function (VariableType) {
    VariableType["string"] = "String";
    VariableType["boolean"] = "Boolean";
    VariableType["number"] = "Number";
    VariableType["json"] = "JSON";
})(VariableType || (VariableType = {}));

class ListAudience {
    _id;
    source;
    appUserKeyName;
    current;
}

class ConfigBody {
    /**
     * Basic project data used for building bucketing response
     */
    project;
    /**
     * Basic environment data used for building bucketing response
     */
    environment;
    /**
     * Fully populated Feature model containing FeatureConfigurations / Variations / Audiences
     */
    features;
    /**
     * All dynamic variables in a project
     */
    variables;
    /**
     * Map of audience id to audience document, used to populate the _audience field for audienceMatch filters
     */
    audiences;
    /**
     * Map of `variable.key` to `hash(variable.key + environment.apiKey)`
     * of all known variable keys. This is used to generate the `knownVariableKeys`
     * in the BucketingAPI response.
     */
    variableHashes;
    /**
     * **Implement Later**
     *
     * All List Audiences in the project
     * TODO make required when implemented
     */
    listAudiences;
    /**
     * List of DevCycle user IDs that are associated to dashboard profiles, indicating their use in debugging features
     */
    debugUsers;
    /**
     * SSE information used for establishing connections.
     */
    sse;
    /**
     * @deprecated Deprecated ably connection/configuration
     */
    ably;
    /**
     * The client SDK key corresponding to this config. Used when a client config is
     * being retrieved via a server SDK key
     */
    clientSDKKey;
}
__decorate([
    Type(() => Feature),
    __metadata("design:type", Array)
], ConfigBody.prototype, "features", void 0);

/**
 * API Populated Event type used in CF Workers / SDKs with all populated event data from the config data
 * ready to be sent to the Events API.
 */
class DVCPopulatedRequestEventDto {
    /**
     * type of the event
     */
    type;
    /**
     * target / subject of event. Contextual to event type
     */
    target;
    /**
     * type of custom event when type == 'customEvent'
     */
    customType;
    /**
     * custom user id of user that triggered event
     */
    user_id;
    /**
     * date event occurred according to server
     */
    date;
    /**
     * date event occurred according to client
     */
    clientDate;
    /**
     * value for numerical events. Contextual to event type
     */
    value;
    /**
     * map of feature ids to variation ids
     */
    featureVars;
    /**
     * extra metadata for event. Contextual to event type
     */
    metaData;
}
__decorate([
    IsString(),
    __metadata("design:type", String)
], DVCPopulatedRequestEventDto.prototype, "type", void 0);
__decorate([
    IsOptional(),
    IsString(),
    __metadata("design:type", String)
], DVCPopulatedRequestEventDto.prototype, "target", void 0);
__decorate([
    IsOptional(),
    IsString(),
    __metadata("design:type", String)
], DVCPopulatedRequestEventDto.prototype, "customType", void 0);
__decorate([
    IsString(),
    IsNotEmpty(),
    __metadata("design:type", String)
], DVCPopulatedRequestEventDto.prototype, "user_id", void 0);
__decorate([
    IsNumber(),
    __metadata("design:type", Number)
], DVCPopulatedRequestEventDto.prototype, "date", void 0);
__decorate([
    IsNumber(),
    __metadata("design:type", Number)
], DVCPopulatedRequestEventDto.prototype, "clientDate", void 0);
__decorate([
    IsOptional(),
    IsNumber(),
    __metadata("design:type", Number)
], DVCPopulatedRequestEventDto.prototype, "value", void 0);
__decorate([
    IsNotEmpty(),
    __metadata("design:type", Object)
], DVCPopulatedRequestEventDto.prototype, "featureVars", void 0);
__decorate([
    IsOptional(),
    __metadata("design:type", Object)
], DVCPopulatedRequestEventDto.prototype, "metaData", void 0);

// Type to retrieve the element type from an array
function getVariableTypeFromValue(value, key, logger, shouldThrow) {
    if (typeof value === 'boolean') {
        return VariableType.boolean;
    }
    else if (typeof value === 'number') {
        return VariableType.number;
    }
    else if (typeof value === 'string') {
        return VariableType.string;
    }
    else if (typeof value === 'object') {
        return VariableType.json;
    }
    else {
        if (shouldThrow) {
            throw new Error(`The default value for variable ${key} is not of type Boolean, Number, String, or JSON`);
        }
        else {
            logger.warn(`The default value for variable ${key} is not of type Boolean, Number, String, or JSON`);
            return null;
        }
    }
}

const isValidDate = (date) => date instanceof Date && !isNaN(date.getTime());
/**
 * Interface representing a source to pull config data from. Used by the Node and Next SDKs
 */
class ConfigSource {
    configEtag;
    configLastModified;
    isLastModifiedHeaderOld(lastModifiedHeader) {
        const lastModifiedHeaderDate = lastModifiedHeader
            ? new Date(lastModifiedHeader)
            : null;
        const configLastModifiedDate = this.configLastModified
            ? new Date(this.configLastModified)
            : null;
        return (isValidDate(configLastModifiedDate) &&
            isValidDate(lastModifiedHeaderDate) &&
            lastModifiedHeaderDate <= configLastModifiedDate);
    }
}

class UserError extends Error {
    constructor(error) {
        super(error instanceof Error ? error.message : error);
        this.name = 'UserError';
        if (error instanceof Error) {
            this.stack = error.stack;
        }
    }
}

export { Audience, AudienceFilter, AudienceFilterOrOperator, AudienceOperator, BooleanFilterComparator, ConfigBody, ConfigSource, DVCAPIUser, DVCBucketingUser, DVCClientAPIUser, DVCEvent, DVCOptInUser, DVCPopulatedRequestEventDto, DataKeyType, Environment, Feature, FeatureConfiguration, FeaturePrerequisites, FeatureSource, FeatureType, FeatureWinningVariation, FilterComparator, FilterType, IsDVCCustomDataJSONObject, ListAudience, ListAudienceSubType, NumberFilterComparator, Project, Audience as PublicAudience, Environment as PublicEnvironment, Feature as PublicFeature, FeatureConfiguration as PublicFeatureConfiguration, Project as PublicProject, Rollout as PublicRollout, RolloutStage as PublicRolloutStage, Target as PublicTarget, Variable as PublicVariable, Variation as PublicVariation, Rollout, RolloutStage, SDKEventRequestBody, SDKTypeValues, SemverFilterComparator, StringFilterComparator, Target, TargetAudience, TargetDistribution, TargetingRuleTypes, TopLevelOperator, UserError, UserSubType, Variable, VariableSource, VariableType, Variation, getVariableTypeFromValue, isValidDate, validate$1 as validate };
